<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[吴化吉 | 我的博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://wuhuaji.me//"/>
  <updated>2015-07-21T14:14:29.670Z</updated>
  <id>http://wuhuaji.me//</id>
  
  <author>
    <name><![CDATA[吴化吉]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[回到过去]]></title>
    <link href="http://wuhuaji.me/2015/07/14/back-to-yesterday/"/>
    <id>http://wuhuaji.me/2015/07/14/back-to-yesterday/</id>
    <published>2015-07-14T11:44:53.000Z</published>
    <updated>2015-07-21T14:14:29.670Z</updated>
    <content type="html"><![CDATA[<p>2015年7月14日上午，刚好有片刻闲暇，我只身一人，盯着烈日来到黎平二中，看看她变成了什么模样。</p>
<p>算起来，2005年秋天去到黎平二中读初中，现在也有10年了，十年没想到这么快就过去了。回到旧地，一切还是老样子，她似乎变旧了一些，当年我们的那栋教学楼没想到还在，只是显得更加陈旧了，而当年刚刚启用的教学楼，也留下了岁的痕迹。</p>
<p>当时正在施工，校园里并不“干净整洁”，我草草转了一圈，拍下两张以证明到此一游的相片也就出来了。</p>
<p>我曾经看过一个电影《回到未来》，说是一个科学家老爷爷，发明了时光机器，然后回到了三十年前，改变了三十年前的历史，因而当他们回到现在时，因为过去被改变了，现在也被改变了（有点绕，推荐去看，非常有趣的电影）。有时候我也不禁会想，如果能回到过去，我会做些什么，而又如何影响我现在的生活？</p>
<p>这是一个很鬼魅的问题，只可惜我们回不去了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2015年7月14日上午，刚好有片刻闲暇，我只身一人，盯着烈日来到黎平二中，看看她变成了什么模样。</p>
<p>算起来，2005年秋天去到黎平二中读初中，现在也有10年了，十年没想到这么快就过去了。回到旧地，一切还是老样子，她似乎变旧了一些，当年我们的那栋教学楼没想到还在]]>
    </summary>
    
      <category term="初中" scheme="http://wuhuaji.me/tags/%E5%88%9D%E4%B8%AD/"/>
    
      <category term="生活" scheme="http://wuhuaji.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[纸质书？电子书？]]></title>
    <link href="http://wuhuaji.me/2015/07/07/ebook-and-paper-book/"/>
    <id>http://wuhuaji.me/2015/07/07/ebook-and-paper-book/</id>
    <published>2015-07-07T11:44:53.000Z</published>
    <updated>2015-07-07T11:49:54.642Z</updated>
    <content type="html"><![CDATA[<p>前天把最后两本书拿去退，才意识到虽然还未毕业，但大四不在学校了（预计），也就可能再也没有机会去图书馆借书了。如此想来，依稀有些伤感，因为我的书单上还有很多书没有读过，很多读过的书也都是囫囵吞枣，实在是遗憾。</p>
<p>现在朝书架上看去，有很多买过的书，都是大学这几年自己买的，随手一列，大概有：</p>
<ul>
<li>《苏菲的世界》</li>
<li>《1984》</li>
<li>《数学之美》</li>
<li>《程序员修炼之道》</li>
<li>《http权威指南》</li>
<li>《锋利的jQuery》</li>
<li>《python核心编程》</li>
</ul>
<p>还要其他一些，不一一列了。</p>
<p>惭愧地说，没有一本是从头到尾看完的，大多是随手翻翻，阅过某些章节，还有一些从未看过。如今要考虑的问题是：毕业了，如何处理？</p>
<p>这些大多是我喜爱的书，视之如瑰宝，自然不愿意贱卖掉。那么毕业之时搬运也是一个问题。现在很流行用户体验这个词，从便携这个角度上来说，纸书的用户体验是比不上电子书的。据说有很多人在下定决心在有自己的房子之前，绝对不买纸质书籍，一律看电子书，因为倘若时常需要搬家，那么搬运纸质书绝对不是一个好的用户体验。</p>
<p>那么电子书有没有可能取代纸质书呢？</p>
<p>事实上我看电子书有一段时间了。大多数时候我用kindle在看小说，在那块6寸的屏幕上看过了金庸、古龙、余华等等，kindle毋庸置疑是看文字类图书的好工具。既能提供纸质书的阅读体验，又能随声携带。但是仅限于文字类的图书，如果是专业书籍，就显得不足，几乎没办法看。在电子书领域里，现在多看阅读做的非常好，特别是在排版上，上面很多专业书籍都做无可挑剔，似乎是一个看专业书籍的好选择。我在上面买了几本技术书籍，都很满意。唯一的问题就是：你可能需要一块大屏幕才能看的舒服，比如我在一块5寸的屏幕上看书就非常累，大脑也不愿意持续地看。所以如果你有一个平板电脑，最好是4:3的屏幕，那估计效果会好很多。</p>
<p>电子书的另外一个问题，就是资源少，不是每一本纸质书都有对应的电子书。实际上根据我的估计，两者的比例可能远远小于1:10。也就是说，你想看一本书，不一定有电子版，也就是说还是要买/借 纸质书才能看。</p>
<p>当然网上有很多盗版的PDF文档，大多是有人照着纸质书扫描，然后上传共享的。如果运气好的话，可能扫描的还算清晰，可以一读，但多数情况扫描出来的质量很糟糕，读起来很不方便。而且这里可能涉及盗版的问题。</p>
<p>说了这么多，你问我兹持电子书还是纸质书，那我当然兹持电子书。只是电子书还有很长的路要走。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前天把最后两本书拿去退，才意识到虽然还未毕业，但大四不在学校了（预计），也就可能再也没有机会去图书馆借书了。如此想来，依稀有些伤感，因为我的书单上还有很多书没有读过，很多读过的书也都是囫囵吞枣，实在是遗憾。</p>
<p>现在朝书架上看去，有很多买过的书，都是大学这几年自己]]>
    </summary>
    
      <category term="电子书" scheme="http://wuhuaji.me/tags/%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
      <category term="纸质书" scheme="http://wuhuaji.me/tags/%E7%BA%B8%E8%B4%A8%E4%B9%A6/"/>
    
      <category term="思考" scheme="http://wuhuaji.me/categories/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用vagrant统一开发环境]]></title>
    <link href="http://wuhuaji.me/2015/06/28/use-vagrant/"/>
    <id>http://wuhuaji.me/2015/06/28/use-vagrant/</id>
    <published>2015-06-28T08:58:02.000Z</published>
    <updated>2015-06-28T09:01:19.390Z</updated>
    <content type="html"><![CDATA[<p>在开发的时候，通常遇到的一个问题是——为什么在我的机器上是正常的，在你那就不能跑了。一般原因无非就是开发环境不同意，缺少某个库、组件、依赖，所以并不是「一次编写，到处运行」，而是<code>「一次编写，到处调试」</code>。特别是在团队合作开发，或者跨平台开发的时候，经常遇到。</p>
<p>那么有没有可能同意开发环境，让每个人的机器都一样的呢？答案就是vagrant。在vagrant里面，就有这一个环境，大家可以都在这个环境里开发，这样就统一了。我也是刚刚了解到这个概念，斗胆一说。</p>
<p>首先：因为我也是初次尝试（而且目前也没人合作开发：）），这里就不列具体命令了，而且这些东西都很容易在网上搜索到。这里只是谈一下我自己的理解。</p>
<p>0，vagrant依赖于<code>VMware</code>或者<code>virtual box</code>之类的虚拟机软件，说到底它就是在虚拟机里构建了一个操作系统。</p>
<p>1，在vagrant里，有一个<code>box</code>的概念，这个box就是一个操作系统（通常是一个linux），你可以去网上下载box（很容易找到），然后安装整个box。这样你就有了第二个操作系统。</p>
<p>2，然后在vagrant这个系统里，你可以搭建你需要的环境，比如你要开发PHP，那就可以把lamp整套装好，各种库，驱动，依赖装好。（这里也可以用网友配置好的box，可以直接使用）</p>
<p>3，好了之后，就可以利用vagrant里的环境进行开发了。这里有一个同步文件夹的概念，可以把vagrant里的文件映射到本地的某个文件夹，所以你可以在宿主系统中，使用你习惯的<code>编辑器 / ide</code>开发，而运行用的是vagrant里的环境。</p>
<p>4，是不是很酷，是！</p>
<p>5，那你要问，如何统一开发环境呢。答案就是vagrant里面的系统可以打包带走。假如这次使用的是ubuntu，明天又使用windows开发，或者团队里来了新成员，都可以把你的vagrant里的系统打包好，然后到windows/新成员的电脑里，重新部署。这样的开发环境就统一了——都用的是vagrant里的环境。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在开发的时候，通常遇到的一个问题是——为什么在我的机器上是正常的，在你那就不能跑了。一般原因无非就是开发环境不同意，缺少某个库、组件、依赖，所以并不是「一次编写，到处运行」，而是<code>「一次编写，到处调试」</code>。特别是在团队合作开发，或者跨平台开发的时候，经]]>
    </summary>
    
      <category term="vagrant" scheme="http://wuhuaji.me/tags/vagrant/"/>
    
      <category term="编程" scheme="http://wuhuaji.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何成为一名黑客]]></title>
    <link href="http://wuhuaji.me/2015/06/16/how-to-become-a-hacker/"/>
    <id>http://wuhuaji.me/2015/06/16/how-to-become-a-hacker/</id>
    <published>2015-06-16T13:55:00.000Z</published>
    <updated>2015-07-09T09:03:02.080Z</updated>
    <content type="html"><![CDATA[<p>《如何成为一名黑客》是著名程序员<code>Eric Steven Raymond</code>写的一个小册子，在早上读完了它，在此记录要点，并加以一些我的理解（可能会有偏差）。</p>
<p>需要说明的是，本文只是笔记，记录了一些我觉得值得关注的要点，如果有人看到这里，我建议还是读原文，很容易在网上找到中文原文：）</p>
<h4 id="什么是真正的黑客">什么是真正的黑客</h4><p>一般大众认为<code>黑客</code>是专门搞破坏的人，实际上那些只能称之为<code>骇客（cracker）</code>。我个人这都是拜媒体宣传所赐。真正的黑客是有指有能力对电脑进行操作，并有建设的人。</p>
<p>一言以蔽之：黑客搞建设，骇客搞破坏。</p>
<h4 id="如何能成为一名黑客">如何能成为一名黑客</h4><ul>
<li>对世界充满好奇（世界上充满了迷人的问题）</li>
<li>一个问题不应该被解决两次 （如果你解决了某个不常见的问题，应该把他们分享出来（不违反商业利益的前提下），帮助别人解决同一个问题）</li>
<li>不要做重复性的工作（想办法把无聊的、乏味工作自动化）</li>
<li>不盲从权威，崇尚自由（所以程序员都是讨厌防火长城的）</li>
<li><strong>态度不能替代能力</strong></li>
</ul>
<h4 id="如何提升能力">如何提升能力</h4><ul>
<li>学会编程 （不要浮躁，十年学会程序设计？）</li>
<li>语言和框架会阻碍思考（要保持开放的心态，不局限于某个语言和框架）</li>
<li>尝试不同的编程范式（c/c++ python java lisp perl ）</li>
<li>读代码（没什么好解释的）</li>
<li>写代码（没什么好解释的）</li>
<li>使用<code>*Unix</code>系统（这一点我暂存异议，因为对于新手来说，使用<code>Windows</code>的学习成本，比类<code>Unix</code>的学习成本低很多）</li>
<li>使用Web把知识、新的分享出去</li>
<li><strong>学好英语</strong>（程序的世界就是英语的世界！！！）</li>
</ul>
<h3 id="其他项">其他项</h3><ul>
<li>编写开源软件</li>
<li>给开源软件做共享</li>
<li>流畅用母语写作</li>
<li>阅读科幻小说</li>
<li>学习武术</li>
<li>练习冥想</li>
<li>不要卷入网络争论（骂战）</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>《如何成为一名黑客》是著名程序员<code>Eric Steven Raymond</code>写的一个小册子，在早上读完了它，在此记录要点，并加以一些我的理解（可能会有偏差）。</p>
<p>需要说明的是，本文只是笔记，记录了一些我觉得值得关注的要点，如果有人看到这里，我]]>
    </summary>
    
      <category term="黑客" scheme="http://wuhuaji.me/tags/%E9%BB%91%E5%AE%A2/"/>
    
      <category term="思考" scheme="http://wuhuaji.me/categories/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再谈JavaScript闭包]]></title>
    <link href="http://wuhuaji.me/2015/06/15/javascript-closure/"/>
    <id>http://wuhuaji.me/2015/06/15/javascript-closure/</id>
    <published>2015-06-15T14:04:49.000Z</published>
    <updated>2015-06-20T14:15:40.000Z</updated>
    <content type="html"><![CDATA[<p>前几天一篇博文谈到的一点闭包，今天看到一些文章，有了另外一些体会，遂再写一篇，权作笔记</p>
<h3 id="什么是闭包">什么是闭包</h3><p>其实闭包的概念并不难得理解，只需要几行代码就可以解释清楚了：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="keyword">array</span> = <span class="string">"this is array"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">array</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testFunc = outer();</span><br><span class="line">console.log(testFunc());<span class="comment">// "this is array"</span></span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，<code>outer</code>这个函数返回的是一个<code>匿名函数</code>，当我调用这个匿名函数时，能够访问到它的父函数里的变量，所以这里能够打印出<code>this is array</code>。</p>
<p>说道这里，<code>闭包</code>的概念已经呼之欲出了，那就是<code>子函数</code>可以访问<code>父函数</code>里的变量。这里更深层的原因是因为子函数的作用域链上包含有父函数的变量，所以能访问到。正因为如此，也就涉及到一个问题：频繁使用闭包，会对性能造成影响。</p>
<h3 id="常见陷阱">常见陷阱</h3><p>说完了闭包是什么，再说下应该注意的地方。<br>最值得注意的地方是，假设父函数有一个变量是不断变化，那么子函数只能取到最后一个变量。<br>用一个例子来说明：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//例子取材自 <span class="type">JavaScript</span>高级程序设计</span><br><span class="line">function createFucntion()&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="literal">result</span> = new <span class="type">Array</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">		<span class="literal">result</span>[i] = function()&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，我们考虑设定一个数组result，其中数组中的每一项的是一个匿名函数，这个函数返回的是数组的索引。</p>
<p>但是<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var foo = createFunction(); //令foo 来接收result</span><br><span class="line">foo[<span class="link_label">0</span>](<span class="link_url"></span>)  //10  !!!</span><br><span class="line">foo[<span class="link_label">1</span>](<span class="link_url"></span>)  //10  !!!</span><br></pre></td></tr></table></figure></p>
<p>这里输出的居然是10 ，而不是他的索引0 /1</p>
<p>这里的解释是当<code>createFunction()</code>函数返回后，i的值已经是10了，那么当我里面的result访问i时，所以都是10。</p>
<p>想要解决这一点，可以试用一个匿名函数，并立即运行，完成赋值：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function createFucntion()&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="literal">result</span> = new <span class="type">Array</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">		<span class="literal">result</span>[i] = function(num)&#123;</span><br><span class="line">			<span class="keyword">return</span> function()&#123;</span><br><span class="line">				<span class="keyword">return</span> num;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;(i);</span><br><span class="line">		///立即执行</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = createFucntion();</span><br><span class="line">console.log(test[<span class="number">1</span>]()); //<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="应用">应用</h3>]]></content>
    <summary type="html">
    <![CDATA[<p>前几天一篇博文谈到的一点闭包，今天看到一些文章，有了另外一些体会，遂再写一篇，权作笔记</p>
<h3 id="什么是闭包">什么是闭包</h3><p>其实闭包的概念并不难得理解，只需要几行代码就可以解释清楚了：<br><figure class="highlight ph]]>
    </summary>
    
      <category term="闭包" scheme="http://wuhuaji.me/tags/%E9%97%AD%E5%8C%85/"/>
    
      <category term="前端" scheme="http://wuhuaji.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写简历，Less和其他]]></title>
    <link href="http://wuhuaji.me/2015/06/15/resume-and-less/"/>
    <id>http://wuhuaji.me/2015/06/15/resume-and-less/</id>
    <published>2015-06-15T14:01:50.000Z</published>
    <updated>2015-06-20T14:35:28.000Z</updated>
    <content type="html"><![CDATA[<p>在我敲下这些文字的时间点里，已经到了六月了，白天在校园里总能看到熙熙攘攘的人群，穿着学士服，在各类标志性建筑物面前留影，摆上各种稀奇古怪的姿势，试图抓住最后这一点光景。</p>
<p>如此想来，自己来到大学已经三年了。还没有什么收获，就快要离开了。想起来大二的某个无所事事的傍晚，路过逸夫楼，正有人在举办欢送典礼，进去听了一下，那时虽然感叹时间匆匆，但也总觉得时间还很多。现如今一个星期有三节课，在可预见的大四几乎没有课（虽然我还有一门课需要重修），如今，离开大学这件事，已经由一个抽象的概念，逐渐变成一个实体了。</p>
<p>据说牛逼的人是不用写简历的，更不用找工作，直接等着人家把offer送到手上就行了，正如NBA的天才球星们一般，只要球打的牛逼，自然有球探追随左右。可是菜鸟如我者，终究还是要写的，今天花了一些时间构建一份简历。事实上我在这学期伊始就在写了。那时我的博客还挂在Github Page 上，也就顺便放在上面，我原本想用旧的简历，再稍加修改草草对付就可以了。又转念一想，既然是要做前端，还是自己动手做的好看一些罢，倘若如此能给我带来一些好运，也不枉费花了一天的时间。</p>
<p>自己构建了一个页面，并没有多复杂，然后CSS部分采用了预处理技术<code>Less</code>。（不懂的人可以建议跳过此段）。之前就有了解过<code>Less Sass</code>这一类的预编译技术，也简单看了一下Less的具体写法，只是感觉很简单，却又能省很多力气，不用写重复代码。但是却也没有怎么实践过。今日用了这个技术。Less 提供了很多便捷处理的技术，就我而言使用的最多的就是 变量和嵌套（几乎只使用这两个）。特别是嵌套，既能省去一部分的代码，又能让你的代码更富有逻辑和层次感。</p>
<p>初次使用就不多做点评了，除了确实感觉到它的便捷之外，最大的感受莫过于——首先要把CSS学好，不然再好用的工具，也只能写出一堆垃圾，我今天就生产出了很多冗余的代码，重用度并不高，归根到底而言还是水平欠缺。</p>
<p>接下来就找机会，物色一些有可能录取我等菜鸟，又不以美女多程序员鼓励师多为亮点的公司，投上几分简历，以求谋得某个前端实习的职位。虽然它们可能石沉大海，了无音讯。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在我敲下这些文字的时间点里，已经到了六月了，白天在校园里总能看到熙熙攘攘的人群，穿着学士服，在各类标志性建筑物面前留影，摆上各种稀奇古怪的姿势，试图抓住最后这一点光景。</p>
<p>如此想来，自己来到大学已经三年了。还没有什么收获，就快要离开了。想起来大二的某个无所事事的]]>
    </summary>
    
      <category term="简历" scheme="http://wuhuaji.me/tags/%E7%AE%80%E5%8E%86/"/>
    
      <category term="生活" scheme="http://wuhuaji.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 原型链]]></title>
    <link href="http://wuhuaji.me/2015/05/22/javascript-prototype/"/>
    <id>http://wuhuaji.me/2015/05/22/javascript-prototype/</id>
    <published>2015-05-22T14:06:20.000Z</published>
    <updated>2015-06-20T14:36:39.000Z</updated>
    <content type="html"><![CDATA[<h4 id="理解原型对象">理解原型对象</h4><p>创建一个对象，就会根据特定的规则为这个对象创建<code>[[prototype]]</code>属性，这个属性指向函数的<code>原型对象</code>，同时原型对象又有一个<code>constructor</code>属性，指向这个对象。</p>
<p>关于<code>[[prototype]]</code>，是无法直接访问的，但是在各个浏览器的实现中，可以通过<code>__proto__</code>去访问。<br>例如：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span></span>{}
a.__proto__
//<span class="function"><span class="keyword">function</span> <span class="title">Empty</span><span class="params">()</span></span> {}
</code></pre><p>又可以通过<code>isPrototypeOf()</code>方法来判断原型对象与实例之间是否存在关系</p>
<pre><code>Function<span class="class">.prototype</span><span class="class">.isPrototypeof</span>(a)
<span class="comment">//true</span>
</code></pre><p> 又可以通过<code>Object.getPrototypeOf()</code>来取得某个对象的原型:</p>
<pre><code>Object.<span class="function"><span class="title">getPrototypeOf</span><span class="params">(a)</span></span>
<span class="comment">//function Empty() {}</span>
</code></pre><p>还可以通过<code>hasOwnProperty()</code>检测实例的某个属性是否来自实例本身。</p>
<pre><code>function <span class="keyword">Person</span>(name){
this.name = name;
}
<span class="keyword">Person</span>.prototype.age = 28;
p1 =new <span class="keyword">Person</span>(<span class="string">"mike"</span>);

console.log(p1.hasOwnProperty(<span class="string">"name"</span>));
//true 来自实例自身
console.log(p1.hasOwnProperty(<span class="string">"age"</span>));
//false 来自原型
</code></pre><p>但是当hasOwnProperty()为false时，却不能说明属性就来自原型（有可能是属性不存在）。那么可以配合<code>in</code>操作符来判断。</p>
<pre><code><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> p1);
<span class="regexp">//</span><span class="literal">true</span> 来自实例本身
<span class="built_in">console</span>.log(<span class="string">"age"</span> <span class="keyword">in</span> p1);
<span class="regexp">//</span><span class="literal">true</span> 来自原型
</code></pre><p>也就说，不管属性来自实例，还是原型，只要能找到这个属性，<code>in</code> 判断就返回true。</p>
<p>所以，我们可以判断，在<code>属性 in 实例</code>返回true，并且<code>hasOwnProperty()</code>返回false的情况下，这个属性就来自原型。</p>
<h4 id="原型继承">原型继承</h4><p>面向对象语言都有三大特性:<code>封装</code>，<code>继承</code>，<code>多态</code>。JavaScript中继承又与其他面向对象语言有些不同，它的继承是通过<code>原型链</code>来实现的。</p>
<p>只需看一段代码，就能大致了解原型继承是什么了：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params"></span>)</span>{
<span class="keyword">this</span>.father = <span class="string">"father"</span>;
}
<span class="function"><span class="keyword">function</span> <span class="title">son</span>(<span class="params"></span>)</span>{
}
son.prototype = <span class="keyword">new</span> father();
<span class="keyword">var</span> foo = <span class="keyword">new</span> son();
<span class="built_in">console</span>.log(foo.father);
<span class="comment">//father</span>
</code></pre><p>在这里首先定义了两个构造函数father 和son。我们知道，创建一个函数，函数内部会有一个<code>[[prototype]]</code>属性指向他的原型对象，当实例需找某个属性是，如果在自身中找不到，就会沿着<code>[[prototype]]</code>找下去。</p>
<p><strong>这里我们把son的prototype属性，手动的指向father的实例（重写了原型对象）</strong>，这里的巧妙之处就体现了：当son中寻找某个属性时，会沿着prototype找下去，而这里prototype指向了father！</p>
<p>所以打印foo.father时foo能够找到father中的father这个属性，继承也就这样实现了。</p>
<p>而所谓<strong>原型链</strong>就是通过对象之间的[[prototype]]的指向，从而实现继承的一个关系（我自己的理解），例如所有的对象对直接或间接的继承了<code>Object</code>(所以所有的对象都有toString hasOwnProperty等方法，都是从Object继承而来了)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="理解原型对象">理解原型对象</h4><p>创建一个对象，就会根据特定的规则为这个对象创建<code>[[prototype]]</code>属性，这个属性指向函数的<code>原型对象</code>，同时原型对象又有一个<code>constructor</co]]>
    </summary>
    
      <category term="原型链" scheme="http://wuhuaji.me/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
      <category term="前端" scheme="http://wuhuaji.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript几种常见的设计模式]]></title>
    <link href="http://wuhuaji.me/2015/05/22/JavaScript-design-pattern/"/>
    <id>http://wuhuaji.me/2015/05/22/JavaScript-design-pattern/</id>
    <published>2015-05-22T13:59:48.000Z</published>
    <updated>2015-06-20T14:14:48.000Z</updated>
    <content type="html"><![CDATA[<h3 id="工厂模式">工厂模式</h3><pre><code>function <span class="literal">factory</span>(name,age,sex){
<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();
o.name = name;
o.age = age;
o.sex  = sex;
<span class="keyword">return</span> o
}

<span class="keyword">var</span> a = <span class="literal">factory</span>(<span class="string">"jack"</span>,<span class="number">25</span>,<span class="string">"man"</span>);
<span class="keyword">var</span> b = <span class="literal">factory</span>(<span class="string">"mike"</span>,<span class="number">20</span>,<span class="string">"women"</span>);
</code></pre><p>在这里<code>factory函数</code>就是一个工厂，给它传递三个参数，就会返回一个包含有这三个函数的对象，就不用每次手动去生成对象了。<br>但是工厂模式有一个缺点：不能识别对象的类型。</p>
<h3 id="构造函数模式">构造函数模式</h3><pre><code>function <span class="keyword">Person</span>(name,age,sex){
this.name = name;
this.age = age;
this.sex = sex;
this.<span class="keyword">say</span>=function(){
    console.log(<span class="string">"hello"</span>);
}
}
var p1 = new <span class="keyword">Person</span>(<span class="string">"张三"</span>,12,<span class="string">"man"</span>);
var p2 = new <span class="keyword">Person</span>(<span class="string">"李四"</span>,15,<span class="string">"man"</span>);
</code></pre><p>这里与工厂模式的区别是，直接把age,name ,sex这些付给this对象，那么当我通过 var p1 = new Person() 创建对象的时候，就创建了一个Person类型的对象，并且把参数作为对象的属性赋值给了p1。</p>
<p>那么<code>function Persion()</code>,就作为p1,p2的构造函数，所以p1,p2就有一个<code>constructor</code>属性指向<code>Person</code></p>
<pre><code>console.<span class="built_in">log</span>(p1.constructor);
//[<span class="function"><span class="keyword">Function</span></span> Person]
</code></pre><p>与工厂模式相比，就能识别出对象的类型，例如这里就能识别出对象是一个<code>Person</code>类型。</p>
<p><strong>值得注意的是，如果构造函数不是通过new来使用，而是直接调用，那么它与普通函数没有什么区别，this就指向当前环境的对象（如果在对象中，就是某个对象如果在全局中，就指向window）</strong></p>
<p>构造函数的缺点，需要多次创建函数对象。那么可以考虑，能否将每个对象的共同部分抽象出来。那么<strong>原型模式</strong>就呼之欲出了。</p>
<h3 id="原型模式">原型模式</h3><p>要使用原型模式，首先要知道原型是什么意思，具体的可以看我上一篇的总结。这里简单说一下。</p>
<p>当我们创建一个对象时，系统会自动为这个对象创建一个<code>原型对象</code>，并且这个对象的<code>[[prototyype]]</code>属性，指向这个<code>原型对象</code>，与此同时，<code>原型对象</code>里又有<code>[[constructor]]</code>属性指回这个对象。</p>
<p>当对象寻找某个属性是，先在自己的属性里面查找，如果找不到，就向它的原型对象查找。</p>
<p>举个例子：</p>
<pre><code>function <span class="keyword">Person</span>(name){
this.name = name;
}
<span class="keyword">Person</span>.prototype.age = 28;
var p1= new <span class="keyword">Person</span>(<span class="string">"mike"</span>);
var p2 = new <span class="keyword">Person</span>(<span class="string">"jack"</span>);
console.log(p1.age);//28
console.log(p2.age);//28
</code></pre><p>在这里首先定义了Person函数，然后通过Person.prototype.age = 28 为它的原型对象添加一个属性age，并设置为28。然后在Person的实例p1,p2中访问age属性，实际上并没有，但是它们能通过向上一级，查找原型对象的属性，所以能打印出28。</p>
<p>这里值得注意的是无论是p1,p2还是以后的pn,都共享了age=28这个属性，也就是说如果：</p>
<pre><code><span class="keyword">Person</span>.prototype.age=29;
</code></pre><p>那么p1,p2的age也会变为29。</p>
<p>这与Java之类的语言中的<code>static</code>这个概念很类似，可以把二者联系起来类比。</p>
<p>还需要注意的是，如果单方面修改实例的值，是为实例添加某个属性，而不会影响原型中的值。看代码：</p>
<pre><code>console.log(p1.age);
//28 这里的值来之<span class="keyword">Person</span>.prototype

<span class="keyword">Person</span>.prototype.age=29;
//修改原型中的值为29

p1.age=30
//p1并没有age这个属性，这一句实际上是为p1加上age这个属性并赋值30。并不影响原型中的age
console.log(p1.age);
//30
//这里因为p1已经有age这个属性了，不用向原型中查找，所以直接打印30

console.log(p2.age);
//29
//而p2还需要向原型中查找，而原型中的age并改为了29,所以打印29。
</code></pre><p>介绍到这里，就可以解决了构造对象模式的缺点，把实例之间所共有的属性加入原型对象中，就不用每次创建对象是赋值共有属性了。</p>
<h4 id="其他设计模式">其他设计模式</h4><p>这只是最基础的三种设计模式，还有很多的设计模式，但几乎都是这三种的变种或组合，我自己还没有很深的体会，暂且不表。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="工厂模式">工厂模式</h3><pre><code>function <span class="literal">factory</span>(name,age,sex){
<span class="keyword">var</span> o = <span cl]]>
    </summary>
    
      <category term="设计模式" scheme="http://wuhuaji.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="前端" scheme="http://wuhuaji.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript作用域链与闭包]]></title>
    <link href="http://wuhuaji.me/2015/05/21/javascript-scope/"/>
    <id>http://wuhuaji.me/2015/05/21/javascript-scope/</id>
    <published>2015-05-21T13:57:40.000Z</published>
    <updated>2015-06-20T14:14:15.000Z</updated>
    <content type="html"><![CDATA[<p><strong>执行环境</strong><br>首先有一个<code>执行环境（execution context）</code>的概念，每一段代码都有自己的执行环境，这个执行环境对应着一个<code>变量对象</code>,每执行一段代码，就会把这段代码的环境压入<code>环境栈</code>中，执行之后再推出栈。</p>
<p><strong>作用域链</strong><br>正如上面所说，函数在执行时，会创建一个<code>执行环境</code>,已经对应的<code>作用域链</code>，并且把内部的<code>[[scope]]</code>属性指向这个<code>作用域链</code>，并且把this，arguments，函数的参数来初始化函数的<code>活动对象（变量对象）</code>，在<code>作用域链</code>函数的自身的活动对象在第一位，外部的活动对象在第二位，外部的外部在第三位……依次类推。如果要寻找某个变量，如果在自己的活动对象里找不到，就依次向上一级寻找。</p>
<p><strong>并且要特别注意，函数的作用域链，在函数的定义时就已经决定了。</strong></p>
<p>这个说有点抽象，举个例子。<br>定义一个最简单的函数：</p>
<pre><code><span class="keyword">var</span> foo=<span class="string">"foo"</span>;
<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>{
<span class="keyword">var</span> foo = <span class="string">"bar"</span>;
<span class="built_in">console</span>.log(foo);
}
test();
<span class="comment">// bar</span>
</code></pre><p>在这个函数里，因为它是在全局中定义，所以在定义这个函数时就决定了它的作用域链是这样的：<br>作用域链的第一位是<code>函数的活动对象</code>，这个活动对象有this ,arguments ,a 等参数。又因为是在全局作用域中定义的，作用域链的第二位，是<code>全局的变量对象</code>，包含全局作用域中的属性已经a 等等。</p>
<p>在执行的时候，就会把这个作用域链压入到环境栈中。所以，在这个例子中，打印foo，就会优先从函数的活动对象找到foo 。所以是<code>bar</code>。</p>
<p>但是如果是这样:</p>
<pre><code>var foo=<span class="string">"foo"</span>;
<span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span>{</span>
<span class="comment">// var foo = "bar";</span>
console.<span class="built_in">log</span><span class="params">(foo)</span>;
}
test<span class="params">()</span>;
<span class="comment">// foo</span>
</code></pre><p>就会打印foo.</p>
<h4 id="闭包">闭包</h4><p>闭包是指有权访问另一个函数作用域中的变量的函数。<br>这么说不好理解，举个例子：</p>
<pre><code><span class="keyword">var</span> obj={
test : <span class="string">"Jobs"</span>
}

<span class="function"><span class="keyword">function</span> <span class="title">fuc</span>(<span class="params">para</span>)</span>{
<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">Object</span>)</span>{
    <span class="keyword">return</span> <span class="built_in">Object</span>[para];
}
}

<span class="keyword">var</span> a = fuc(<span class="string">"test"</span>);
<span class="built_in">console</span>.log(a(obj));
<span class="comment">//Jobs</span>
</code></pre><p>在这里，首先定义一个函数fuc，它返回一个匿名函数。<br>然后用调用这个函数，并用a接收函数的返回值，也就是说现在a指向这这个返回的函数，通过a(obj)调用函数。</p>
<p>这里吊诡的地方在于，para是func的参数，在调用a()的时候，如何能使用para的值呢？</p>
<p>如果理解了作用域链就知道了，这是可以的。首先对于函数func内部的匿名函数，它的作用域链的前端首先是自身的活动对象，下一级是func的变量对象，然后再到全局的变量对象。所以在需要使用para的时候，会一级级的找下去。</p>
<p>这里内部的匿名函数能使用外部函数的变量，这就是闭包的原理。</p>
<p>这里需要注意的是 var a = func(‘test’)，这一句之后，函数对象并没有销毁，因为返回的匿名函数的作用域链还在指向这个活动对象，知道匿名函数销毁后，函数这个活动对象才会被销毁。<strong>这也是为什么大量使用闭包，会对性能有影响的原因。</strong></p>
<h4 id="JavaScript_的预编译">JavaScript 的预编译</h4><p>JS 每段代码在执行之前，有一个预编译的过程，会首先处理<code>var</code>关键字和<code>function</code>声明。</p>
<p>这里引用鸟哥的<a href="http://www.laruence.com/2009/05/28/863.html" target="_blank" rel="external">描述</a></p>
<blockquote>
<p> 在调用函数执行之前, 会首先创建一个活动对象, 然后搜寻这个函数中的局部变量定义,和函数定义, 将变量名和函数名都做为这个活动对象的同名属性, 对于局部变量定义,变量的值会在真正执行的时候才计算, 此时只是简单的赋为undefined.</p>
</blockquote>
<p>所以，当我们有：</p>
<pre><code>foo<span class="params">()</span>;
<span class="comment">//foo</span>
<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span>{</span>
    console.<span class="built_in">log</span><span class="params">(<span class="string">"foo"</span>)</span>;
}
</code></pre><p>这里似乎调用foo()之时，函数都还没有定义，怎么能打印出值呢？这里就是预编译的神奇之处，相当于已经把foo的声明提前了，所以能打印出值。</p>
<p>但是函数表达式却不然，因为函数表达式是一个赋值（计算）的过程，这是要在执行当中才计算的。所以：</p>
<pre><code>foo<span class="params">()</span>;
<span class="comment">//foo is not defined</span>
foo = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    console.<span class="built_in">log</span><span class="params">(<span class="string">"foo"</span>)</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>执行环境</strong><br>首先有一个<code>执行环境（execution context）</code>的概念，每一段代码都有自己的执行环境，这个执行环境对应着一个<code>变量对象</code>,每执行一段代码，就会把这段代码的环境压入<co]]>
    </summary>
    
      <category term="JavaScript" scheme="http://wuhuaji.me/tags/JavaScript/"/>
    
      <category term="作用域链" scheme="http://wuhuaji.me/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    
      <category term="闭包" scheme="http://wuhuaji.me/tags/%E9%97%AD%E5%8C%85/"/>
    
      <category term="前端" scheme="http://wuhuaji.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>